<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WindowChain Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 p-8">
    <div class="max-w-4xl mx-auto">
      <h1 class="text-3xl font-bold mb-8">WindowChain Demo</h1>

      <!-- Model Status -->
      <div class="bg-white p-6 rounded-lg shadow-md mb-8">
        <h2 class="text-xl font-semibold mb-4">Model Status</h2>
        <div id="modelStatus" class="text-gray-600">
          Checking model availability...
        </div>
        <div id="downloadProgress" class="hidden mt-4">
          <div class="w-full bg-gray-200 rounded-full h-2.5">
            <div
              id="downloadBar"
              class="bg-blue-600 h-2.5 rounded-full"
              style="width: 0%"
            ></div>
          </div>
          <div id="downloadText" class="text-sm text-gray-500 mt-1"></div>
        </div>
      </div>

      <!-- Basic Chain -->
      <div class="bg-white p-6 rounded-lg shadow-md mb-8">
        <h2 class="text-xl font-semibold mb-4">Basic Chain</h2>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700">Input</label>
          <input
            type="text"
            id="basicInput"
            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border"
            placeholder="Enter your message"
            value="What is your favorite color?"
          />
        </div>
        <div class="space-x-2">
          <button
            id="basicSend"
            class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
          >
            Send
          </button>
          <button
            id="basicStream"
            class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
          >
            Stream
          </button>
          <button
            id="basicStop"
            class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600"
            disabled
          >
            Stop
          </button>
        </div>
        <div
          id="basicOutput"
          class="mt-4 p-4 bg-gray-50 rounded min-h-[100px] whitespace-pre-wrap"
        ></div>
        <div id="basicTokens" class="mt-2 text-sm text-gray-500"></div>
      </div>

      <!-- Templated Chain -->
      <div class="bg-white p-6 rounded-lg shadow-md mb-8">
        <h2 class="text-xl font-semibold mb-4">Templated Chain</h2>
        <div class="grid grid-cols-2 gap-4 mb-4">
          <div>
            <label class="block text-sm font-medium text-gray-700"
              >Text to Translate</label
            >
            <input
              type="text"
              id="templateText"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border"
              value="Hello world"
            />
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700"
              >Target Language</label
            >
            <select
              id="templateLang"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border"
            >
              <option value="es">Spanish</option>
              <option value="fr">French</option>
              <option value="de">German</option>
            </select>
          </div>
        </div>
        <button
          id="templateSend"
          class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        >
          Translate
        </button>
        <div
          id="templateOutput"
          class="mt-4 p-4 bg-gray-50 rounded min-h-[100px]"
        ></div>
      </div>

      <!-- JSON Output Chain -->
      <div class="bg-white p-6 rounded-lg shadow-md mb-8">
        <h2 class="text-xl font-semibold mb-4">Structured Output</h2>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700"
            >Analyze Text</label
          >
          <textarea
            id="jsonInput"
            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border"
            rows="3"
          >
I absolutely love this product! It's amazing and has completely changed my life for the better.</textarea
          >
        </div>
        <button
          id="jsonSend"
          class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        >
          Analyze Sentiment
        </button>
        <div
          id="jsonOutput"
          class="mt-4 p-4 bg-gray-50 rounded min-h-[100px] font-mono text-sm"
        ></div>
      </div>

      <!-- Chat Chain -->
      <div class="bg-white p-6 rounded-lg shadow-md mb-8">
        <h2 class="text-xl font-semibold mb-4">Chat Interaction</h2>
        <div
          id="chatHistory"
          class="mb-4 p-4 bg-gray-50 rounded max-h-[400px] overflow-y-auto space-y-4"
        ></div>
        <div class="flex gap-2">
          <input
            type="text"
            id="chatInput"
            class="flex-1 rounded-md border-gray-300 shadow-sm p-2 border"
            placeholder="Type your message"
          />
          <button
            id="chatSend"
            class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
          >
            Send
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      // Import WindowChain (assuming it's in window-chain.mjs)
      import {
        ChatPromptTemplate,
        LLMChain,
        ChainError,
      } from "./window-chain.mjs";

      // Initialize UI elements
      const elements = {
        modelStatus: document.getElementById("modelStatus"),
        downloadProgress: document.getElementById("downloadProgress"),
        downloadBar: document.getElementById("downloadBar"),
        downloadText: document.getElementById("downloadText"),
        basicInput: document.getElementById("basicInput"),
        basicSend: document.getElementById("basicSend"),
        basicStream: document.getElementById("basicStream"),
        basicStop: document.getElementById("basicStop"),
        basicOutput: document.getElementById("basicOutput"),
        basicTokens: document.getElementById("basicTokens"),
        templateText: document.getElementById("templateText"),
        templateLang: document.getElementById("templateLang"),
        templateSend: document.getElementById("templateSend"),
        templateOutput: document.getElementById("templateOutput"),
        jsonInput: document.getElementById("jsonInput"),
        jsonSend: document.getElementById("jsonSend"),
        jsonOutput: document.getElementById("jsonOutput"),
        chatInput: document.getElementById("chatInput"),
        chatSend: document.getElementById("chatSend"),
        chatHistory: document.getElementById("chatHistory"),
      };

      // Helper functions
      function setLoading(element, isLoading) {
        if (isLoading) {
          element.classList.add("opacity-50");
          element.classList.add("cursor-wait");
        } else {
          element.classList.remove("opacity-50");
          element.classList.remove("cursor-wait");
        }
      }

      function addChatMessage(role, content) {
        console.log("Adding chat message:", { role, content });
        const messageDiv = document.createElement("div");
        messageDiv.className = `p-3 rounded ${
          role === "assistant"
            ? "bg-blue-50 ml-4"
            : role === "system"
            ? "bg-red-50"
            : "bg-gray-200 mr-4"
        }`;

        // Add loading spinner for assistant messages
        if (role === "assistant" && content === "...") {
          messageDiv.innerHTML = `
                    <div class="flex items-center gap-2">
                        <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500"></div>
                        <span>Thinking...</span>
                    </div>
                `;
        } else {
          messageDiv.textContent = content;
        }

        elements.chatHistory.appendChild(messageDiv);
        elements.chatHistory.scrollTop = elements.chatHistory.scrollHeight;
        return messageDiv;
      }

      // Global conversation history
      let chatMessages = [];
      let basicChain, templateChain, jsonChain, chatChain;
      let abortController = null;

      async function initializeChains() {
        try {
          // Basic chain
          basicChain = new LLMChain({
            onProgress: (progress) => {
              if (progress.type === "download") {
                elements.downloadProgress.classList.remove("hidden");
                const percent = (progress.loaded / progress.total) * 100;
                elements.downloadBar.style.width = `${percent}%`;
                elements.downloadText.textContent = `Downloaded ${Math.round(
                  progress.loaded / 1024
                )}KB of ${Math.round(progress.total / 1024)}KB`;
              }
            },
          });

          // Template chain for translation
          const translateTemplate = ChatPromptTemplate.fromMessages(
            [
              ["system", "You are a helpful translator."],
              ["user", "Translate '{text}' to {language}."],
            ],
            {
              text: { required: true },
              language: {
                required: true,
                validator: (lang) => ["es", "fr", "de"].includes(lang),
                formatter: (lang) =>
                  ({
                    es: "Spanish",
                    fr: "French",
                    de: "German",
                  }[lang]),
              },
            }
          );

          templateChain = new LLMChain({
            promptTemplate: translateTemplate,
          });

          // JSON chain for sentiment analysis
          const jsonTemplate = ChatPromptTemplate.fromMessages([
            [
              "system",
              "You are a sentiment analyzer that ONLY outputs valid JSON objects. NEVER give explanations or examples. NEVER use markdown formatting. NEVER use backticks. Output MUST be a single JSON object with exactly these three fields: sentiment (string), score (number), and keywords (array of strings).",
            ],
            ["user", "Analyze this sentiment: {text}"],
          ]);

          jsonChain = new LLMChain({
            promptTemplate: jsonTemplate,
            temperature: 0.1, // Lower temperature for more consistent output
          });

          // Chat chain with conversation history
          chatMessages = [
            // [
            //   "system",
            //   "You are a friendly conversational AI. NEVER give programming advice or technical explanations unless explicitly asked. If someone inputs a math expression, simply calculate it. If someone asks a question, give a direct, simple answer. Keep all responses under 50 words and conversational in tone. No technical jargon or code examples unless specifically requested.",
            // ],
          ];

          chatChain = new LLMChain({
            temperature: 0.7,
          });

          // Reset chat history display
          elements.chatHistory.innerHTML = "";

          elements.modelStatus.textContent = "Model ready!";
          elements.modelStatus.className = "text-green-600";
        } catch (error) {
          elements.modelStatus.textContent = `Error: ${error.message}`;
          elements.modelStatus.className = "text-red-600";
        }
      }

      // Event handlers
      elements.basicSend.onclick = async () => {
        elements.basicOutput.textContent = "Thinking...";
        try {
          const result = await basicChain.invoke(elements.basicInput.value);
          elements.basicOutput.textContent = result.content;
          const info = await basicChain.getModelInfo();
          elements.basicTokens.textContent = `Tokens: ${info.tokensSoFar}/${info.maxTokens} (${info.tokensLeft} left)`;
        } catch (error) {
          elements.basicOutput.textContent = `Error: ${error.message}`;
        }
      };

      elements.basicStream.onclick = async () => {
        elements.basicOutput.textContent = "";
        elements.basicStop.disabled = false;
        abortController = new AbortController();

        try {
          const stream = await basicChain.invoke(elements.basicInput.value, {
            streaming: true,
            signal: abortController.signal,
          });

          for await (const chunk of stream) {
            elements.basicOutput.textContent += chunk;
          }
        } catch (error) {
          if (error.name !== "AbortError") {
            elements.basicOutput.textContent += `\nError: ${error.message}`;
          }
        } finally {
          elements.basicStop.disabled = true;
          abortController = null;
        }
      };

      elements.basicStop.onclick = () => {
        if (abortController) {
          abortController.abort();
        }
      };

      elements.templateSend.onclick = async () => {
        elements.templateOutput.textContent = "Translating...";
        try {
          const result = await templateChain.invoke({
            text: elements.templateText.value,
            language: elements.templateLang.value,
          });
          elements.templateOutput.textContent = result.content;
        } catch (error) {
          elements.templateOutput.textContent = `Error: ${error.message}`;
        }
      };

      elements.jsonSend.onclick = async () => {
        elements.jsonOutput.textContent = "Analyzing...";
        try {
          try {
            const result = await jsonChain.invoke({
              text: elements.jsonInput.value,
            });

            // Remove any non-JSON content and attempt to find a JSON object
            const jsonMatch = result.content.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
              throw new Error("No JSON object found in response");
            }

            const jsonResponse = JSON.parse(jsonMatch[0]);

            // Validate the required fields
            if (
              !jsonResponse.sentiment ||
              !jsonResponse.score ||
              !Array.isArray(jsonResponse.keywords)
            ) {
              throw new Error("Response missing required fields");
            }

            elements.jsonOutput.textContent = JSON.stringify(
              jsonResponse,
              null,
              2
            );
          } catch (error) {
            console.error("Raw response:", result?.content);
            elements.jsonOutput.textContent = `Error: ${error.message}\n\nPlease try again.`;
          }
        } catch (error) {
          elements.jsonOutput.textContent = `Error: ${error.message}`;
        }
      };

      elements.chatSend.onclick = async () => {
        const input = elements.chatInput.value;
        if (!input.trim()) return;

        addChatMessage("user", input);
        elements.chatInput.value = "";

        try {
          // Add user message to conversation history
          console.log("Processing chat input:", input);
          chatMessages.push(["user", input]);

          // Create a new array with just the required messages to maintain a reasonable context window
          const recentMessages = chatMessages.slice(-5); // Keep last 5 messages for context
          console.log("Recent messages for context:", recentMessages);

          // Show loading state
          const loadingMessage = addChatMessage("assistant", "...");
          setLoading(elements.chatInput, true);
          elements.chatSend.disabled = true;

          // Handle simple math expressions
          if (input.match(/^[\d\s+\-*/()\s]*$/)) {
            console.log("Detected math expression, attempting evaluation");
            try {
              const mathResult = eval(input);
              if (!isNaN(mathResult)) {
                console.log("Math evaluation successful:", mathResult);
                loadingMessage.remove();
                addChatMessage("assistant", `${mathResult}`);
                chatMessages.push(["assistant", `${mathResult}`]);
                return;
              }
            } catch (e) {
              console.log("Math evaluation failed:", e);
              // If eval fails, continue with normal response
            }
          }

          // Get response using conversation history
          console.log("Requesting model response");
          const result = await chatChain.invoke(recentMessages);
          console.log("Received model response:", result);

          // Remove loading message and add real response
          loadingMessage.remove();

          // Add assistant response to history
          chatMessages.push(["assistant", result.content]);
          addChatMessage("assistant", result.content);
        } catch (error) {
          console.error("Chat error:", error);
          addChatMessage("system", `Error: ${error.message}`);
        } finally {
          setLoading(elements.chatInput, false);
          elements.chatSend.disabled = false;
          elements.chatInput.focus();
        }
      };

      elements.chatInput.onkeypress = (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          elements.chatSend.click();
        }
      };

      // Initialize everything
      await initializeChains();
    </script>
  </body>
</html>
